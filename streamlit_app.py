#!/usr/bin/env python3
"""
Streamlit UI for IA Continu Solution
Interface utilisateur pour tester l'API avec authentification
"""

import streamlit as st
import requests
import json
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import time
import os

# Configuration de la page
st.set_page_config(
    page_title="IA Continu Solution - Dashboard",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configuration API
API_BASE_URL = os.getenv("API_URL", "http://localhost:8000")

class APIClient:
    """Client pour interagir avec l'API"""
    
    def __init__(self, base_url: str, token: str = None):
        self.base_url = base_url
        self.token = token
        self.headers = {}
        if token:
            self.headers["Authorization"] = f"Bearer {token}"
    
    def health_check(self):
        """V√©rifier la sant√© de l'API"""
        try:
            response = requests.get(f"{self.base_url}/health", headers=self.headers, timeout=5)
            return response.status_code == 200, response.json() if response.status_code == 200 else None
        except Exception as e:
            return False, str(e)
    
    def predict(self, features):
        """Faire une pr√©diction"""
        try:
            payload = {"features": features}
            response = requests.post(f"{self.base_url}/predict", json=payload, headers=self.headers, timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)
    
    def generate_dataset(self, samples=1000):
        """G√©n√©rer un nouveau dataset"""
        try:
            payload = {"samples": samples}
            response = requests.post(f"{self.base_url}/generate", json=payload, headers=self.headers, timeout=30)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)
    
    def retrain_model(self):
        """R√©entra√Æner le mod√®le"""
        try:
            response = requests.post(f"{self.base_url}/retrain", headers=self.headers, timeout=60)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)
    
    def conditional_retrain(self, threshold=0.85, force=False):
        """R√©entra√Ænement conditionnel"""
        try:
            payload = {"accuracy_threshold": threshold, "force_retrain": force}
            response = requests.post(f"{self.base_url}/retrain/conditional", json=payload, headers=self.headers, timeout=60)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)
    
    def get_model_info(self):
        """Obtenir les informations du mod√®le"""
        try:
            response = requests.get(f"{self.base_url}/model/info", headers=self.headers, timeout=5)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)
    
    def list_datasets(self):
        """Lister les datasets"""
        try:
            response = requests.get(f"{self.base_url}/datasets/list", headers=self.headers, timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except Exception as e:
            return False, str(e)

def authenticate():
    """Interface d'authentification"""
    st.sidebar.title("üîê Authentification")
    
    # Token d'authentification
    token = st.sidebar.text_input("Token d'acc√®s", type="password", help="Entrez votre token JWT")
    
    if token:
        st.session_state.token = token
        st.session_state.api_client = APIClient(API_BASE_URL, token)
        
        # Tester la connexion
        is_healthy, health_data = st.session_state.api_client.health_check()
        if is_healthy:
            st.sidebar.success("‚úÖ Authentifi√© et connect√© √† l'API")
            return True
        else:
            st.sidebar.error("‚ùå Erreur de connexion √† l'API")
            st.sidebar.error(f"D√©tails: {health_data}")
            return False
    else:
        st.sidebar.warning("‚ö†Ô∏è Token requis pour acc√©der √† l'API")
        return False

def main_dashboard():
    """Dashboard principal"""
    st.title("ü§ñ IA Continu Solution - Dashboard")
    st.markdown("Interface de gestion et monitoring du pipeline ML")
    
    # V√©rifier la sant√© de l'API
    is_healthy, health_data = st.session_state.api_client.health_check()
    
    if is_healthy:
        st.success(f"‚úÖ API Status: {health_data.get('status', 'OK')} - Version: {health_data.get('version', 'N/A')}")
    else:
        st.error(f"‚ùå API non disponible: {health_data}")
        return
    
    # Tabs pour organiser les fonctionnalit√©s
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üéØ Pr√©dictions", "üîÑ Mod√®le", "üìä Datasets", "üìà Monitoring", "‚öôÔ∏è Admin"])
    
    with tab1:
        prediction_interface()
    
    with tab2:
        model_management()
    
    with tab3:
        dataset_management()
    
    with tab4:
        monitoring_dashboard()
    
    with tab5:
        admin_interface()

def prediction_interface():
    """Interface de pr√©diction"""
    st.header("üéØ Interface de Pr√©diction")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Param√®tres d'entr√©e")
        feature1 = st.number_input("Feature 1", value=0.5, step=0.1, format="%.2f")
        feature2 = st.number_input("Feature 2", value=0.5, step=0.1, format="%.2f")
        
        if st.button("üöÄ Faire une pr√©diction", type="primary"):
            with st.spinner("Pr√©diction en cours..."):
                success, result = st.session_state.api_client.predict([feature1, feature2])
                
                if success:
                    st.success("‚úÖ Pr√©diction r√©ussie!")
                    
                    # Afficher les r√©sultats
                    col_pred, col_conf = st.columns(2)
                    with col_pred:
                        st.metric("Pr√©diction", result["prediction"])
                    with col_conf:
                        st.metric("Confiance", f"{result['confidence']:.3f}")
                    
                    st.json(result)
                else:
                    st.error(f"‚ùå Erreur de pr√©diction: {result}")
    
    with col2:
        st.subheader("Pr√©dictions en lot")
        
        # Interface pour pr√©dictions multiples
        num_predictions = st.number_input("Nombre de pr√©dictions", min_value=1, max_value=100, value=10)
        
        if st.button("üé≤ G√©n√©rer pr√©dictions al√©atoires"):
            import random
            predictions_data = []
            
            progress_bar = st.progress(0)
            for i in range(num_predictions):
                f1 = random.uniform(-2, 2)
                f2 = random.uniform(-2, 2)
                
                success, result = st.session_state.api_client.predict([f1, f2])
                if success:
                    predictions_data.append({
                        "Feature1": f1,
                        "Feature2": f2,
                        "Prediction": result["prediction"],
                        "Confidence": result["confidence"]
                    })
                
                progress_bar.progress((i + 1) / num_predictions)
            
            if predictions_data:
                df = pd.DataFrame(predictions_data)
                st.dataframe(df)
                
                # Graphique des pr√©dictions
                fig = px.scatter(df, x="Feature1", y="Feature2", color="Prediction", 
                               size="Confidence", title="Visualisation des pr√©dictions")
                st.plotly_chart(fig, use_container_width=True)

def model_management():
    """Interface de gestion du mod√®le"""
    st.header("üîÑ Gestion du Mod√®le")
    
    # Informations du mod√®le actuel
    success, model_info = st.session_state.api_client.get_model_info()
    
    if success:
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Version", model_info.get("model_version", "N/A"))
        with col2:
            st.metric("Type", model_info.get("model_type", "N/A"))
        with col3:
            status = "‚úÖ Charg√©" if model_info.get("model_loaded", False) else "‚ùå Non charg√©"
            st.metric("Status", status)
    
    st.subheader("Actions sur le mod√®le")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### R√©entra√Ænement Standard")
        if st.button("üîÑ R√©entra√Æner le mod√®le", type="primary"):
            with st.spinner("R√©entra√Ænement en cours..."):
                success, result = st.session_state.api_client.retrain_model()
                
                if success:
                    st.success("‚úÖ R√©entra√Ænement r√©ussi!")
                    st.json(result)
                else:
                    st.error(f"‚ùå Erreur de r√©entra√Ænement: {result}")
    
    with col2:
        st.markdown("### R√©entra√Ænement Conditionnel")
        threshold = st.slider("Seuil de pr√©cision", 0.0, 1.0, 0.85, 0.05)
        force_retrain = st.checkbox("Forcer le r√©entra√Ænement")
        
        if st.button("üéØ √âvaluation conditionnelle"):
            with st.spinner("√âvaluation en cours..."):
                success, result = st.session_state.api_client.conditional_retrain(threshold, force_retrain)
                
                if success:
                    if result.get("retrain_triggered", False):
                        st.success("‚úÖ R√©entra√Ænement d√©clench√©!")
                    else:
                        st.info("‚ÑπÔ∏è Pas de r√©entra√Ænement n√©cessaire")
                    
                    # Afficher les d√©tails
                    col_acc, col_thresh = st.columns(2)
                    with col_acc:
                        st.metric("Pr√©cision actuelle", f"{result.get('current_accuracy', 0):.3f}")
                    with col_thresh:
                        st.metric("Seuil", f"{result.get('threshold', 0):.3f}")
                    
                    st.info(result.get("details", ""))
                    st.json(result)
                else:
                    st.error(f"‚ùå Erreur d'√©valuation: {result}")

def dataset_management():
    """Interface de gestion des datasets"""
    st.header("üìä Gestion des Datasets")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("G√©n√©rer nouveau dataset")
        samples = st.number_input("Nombre d'√©chantillons", min_value=100, max_value=10000, value=1000, step=100)
        
        if st.button("üìä G√©n√©rer dataset"):
            with st.spinner("G√©n√©ration en cours..."):
                success, result = st.session_state.api_client.generate_dataset(samples)
                
                if success:
                    st.success("‚úÖ Dataset g√©n√©r√© avec succ√®s!")
                    st.json(result)
                else:
                    st.error(f"‚ùå Erreur de g√©n√©ration: {result}")
    
    with col2:
        st.subheader("Datasets existants")
        
        if st.button("üîÑ Actualiser la liste"):
            success, datasets = st.session_state.api_client.list_datasets()
            
            if success and datasets.get("datasets"):
                df = pd.DataFrame(datasets["datasets"])
                st.dataframe(df)
                
                # Graphique de l'√©volution
                if len(df) > 1:
                    fig = px.line(df, x="created_at", y="samples_count", 
                                title="√âvolution du nombre d'√©chantillons")
                    st.plotly_chart(fig, use_container_width=True)
            else:
                st.warning("Aucun dataset trouv√©")

def monitoring_dashboard():
    """Dashboard de monitoring"""
    st.header("üìà Monitoring")
    
    st.markdown("""
    ### Liens vers les outils de monitoring
    
    - üîç **Prometheus**: [http://localhost:9090](http://localhost:9090)
    - üìä **Grafana**: [http://localhost:3000](http://localhost:3000) (admin/admin123)
    - üì° **Uptime Kuma**: [http://localhost:3001](http://localhost:3001)
    - üî¨ **MLflow**: [http://localhost:5000](http://localhost:5000)
    - ‚ö° **Prefect**: [http://localhost:4200](http://localhost:4200)
    """)
    
    # M√©triques en temps r√©el (simulation)
    if st.button("üìä Actualiser les m√©triques"):
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("API Requests", "1,234", "12%")
        with col2:
            st.metric("Model Accuracy", "0.923", "0.05")
        with col3:
            st.metric("Uptime", "99.9%", "0.1%")
        with col4:
            st.metric("Response Time", "45ms", "-5ms")

def admin_interface():
    """Interface d'administration"""
    st.header("‚öôÔ∏è Administration")
    
    st.warning("üö® Zone d'administration - Utilisez avec pr√©caution")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Configuration API")
        st.text_input("URL de base", value=API_BASE_URL, disabled=True)
        st.text_input("Token actuel", value="***", type="password", disabled=True)
    
    with col2:
        st.subheader("Actions syst√®me")
        
        if st.button("üîÑ Red√©marrer les services", type="secondary"):
            st.warning("Cette action red√©marrerait tous les services Docker")
        
        if st.button("üóëÔ∏è Nettoyer les logs", type="secondary"):
            st.warning("Cette action supprimerait les anciens fichiers de logs")
    
    # Logs en temps r√©el (simulation)
    st.subheader("üìù Logs r√©cents")
    if st.button("üîÑ Actualiser les logs"):
        logs = [
            "2024-01-01 12:00:00 - INFO - API started successfully",
            "2024-01-01 12:01:00 - INFO - Model loaded: v20240101_120000",
            "2024-01-01 12:02:00 - INFO - Prediction made: confidence 0.85",
            "2024-01-01 12:03:00 - WARNING - Model drift detected",
            "2024-01-01 12:04:00 - INFO - Retraining triggered"
        ]
        
        for log in logs:
            st.text(log)

def main():
    """Fonction principale"""
    st.sidebar.image("https://via.placeholder.com/200x100/1f77b4/white?text=IA+Continu", width=200)
    
    # Authentification
    if not authenticate():
        st.warning("üîê Veuillez vous authentifier pour acc√©der au dashboard")
        st.markdown("""
        ### Comment obtenir un token ?
        
        1. Contactez l'administrateur syst√®me
        2. Utilisez l'endpoint `/auth/login` de l'API
        3. Pour les tests, utilisez le token de d√©veloppement
        """)
        return
    
    # Dashboard principal
    main_dashboard()
    
    # Footer
    st.sidebar.markdown("---")
    st.sidebar.markdown("**IA Continu Solution v3.0**")
    st.sidebar.markdown("Jour 3 - Monitoring & Application")

if __name__ == "__main__":
    main()
